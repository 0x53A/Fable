 - tagline: Extending Fable via plugins

# Fable plugins

Is it very easy to add features to Fable using plugins. The best example is the plugin
to transform [NUnit tests into Mocha](https://github.com/fable-compiler/Fable/blob/master/src/plugins/nunit/Fable.Plugins.NUnit.fsx). In order to understand the plugin
system we'll review briefly how Fable works.

## Overview of Fable's architecture

Thanks to the [F# compiler](http://fsharp.github.io/FSharp.Compiler.Service/)
and [Babel](http://babeljs.io), the work of Fable is very simple: transform
the AST generated by the F# compiler into one understandable by Babel.
This way, it's not necessary to deal directly with F# or JavaScript code.
Moreover, several tasks can be delegated to Babel, like compiling from ES2015 to ES5
or using different module systems according to the target environment.

In between these two ASTs, Fable sneaks its own one. The reason for that
is to have something more manageable than the AST provided by the F# compiler
for internal transformation and optimizations. Plugins will work against
this intermediate Fable AST.

During the AST transformation process, several hooks are available for plugins.
The most important one is the call replacement, that is, when Fable tries to
replace a call to a type or module member (method, constructor, property...).
Below, we are going to learn how to create a plugin to replace some of these calls.
Another useful plugin lets you transform Fable AST after it has been obtained
from F# source code. This is briefly outlined in the second demo in this article.

## Creating call replacement plugin

Fable's goal is to support most of the F# core library and some of the most
used classes in .NET BCL, like `DateTime` or `Regex`. Fable now supports
`System.Random` too, but for the sake of practicing let's write a plugin
as if it wouldn't.

The simplest way to create a plugin is just to use a F# script file and that's
what we'll be doing here. Create a file named `Fable.Plugins.Random.fsx` and
put a reference to `Fable.Core.dll` as follows (fix the path according to where
you place the plugin):

```fsharp
namespace Fable.Plugins

#r "../../../build/fable-core/Fable.Core.dll"

open Fable
open Fable.AST
```

> We opened a couple of namespaces to have access to
the functions and types we'll be using from Fable.

Now we just need to expose a type with a parameterless constructor
implementing one of the `IPlugin` interfaces in Fable. These interfaces expose
one or several methods returning an option. When performing a transformation,
if there's a hook available, Fable will try to look for a plugin to deal with
the transformation. If there's no plugin or all plugins return `None` it will
take care of the transformation itself.

In most cases we'll want to implement `IReplacePlugin` to replace external calls.
We don't have to write too much boilerplate for that:

```fsharp
type RandomPlugin() =
    interface IReplacePlugin with
        member x.TryReplace com (info: Fable.ApplyInfo) =
            None
```

Right now this plugin won't do anything as it always return `None` but we
can have a look at the signature of the method we need to implement to
understand what's going on. Every time Fable encounters a call in the F# AST,
it will call this method and pass a couple of arguments: the first one
contains the compiler options and we don't need to worry about it for now.
The second one is more interesting and contains a lot of information about
the call we need to replace. `ApplyInfo` has the following definition:

```fsharp
type ApplyInfo = {
    ownerType: Fable.Type
    /// Sometimes Fable.Type may differ from original F# name
    /// (e.g. System.Object -> Fable.Any). This keeps the original name.
    ownerFullName: string
    methodName: string
    methodKind: MemberKind
    callee: Fable.Expr option
    args: Fable.Expr list
    returnType: Fable.Type
    range: SourceLocation option
    fileName: string
    decorators: Decorator list
    calleeTypeArgs: Fable.Type list
    methodTypeArgs: Fable.Type list
    /// If the method accepts a lambda as first argument,
    /// indicates its arity
    lambdaArgArity: int
}
```

We're going to focus on the first fields: `ownerFullName` and `methodName`
make it possible to identify the method. The next two fields expose the instance object
(which maybe `None` if the method is static or a constructor) and the arguments,
already transformed into Fable expressions.

With this information, let's identify calls to `System.Random`. This time we'll
only try to replace two methods: the constructor and `Next`.

```fsharp
member x.TryReplace com (info: Fable.ApplyInfo) =
    match info.ownerFullName with
    | "System.Random" ->
        match info.methodName with
        | ".ctor" -> failwith "TODO"
        | "Next" -> failwith "TODO"
        | _ -> None
    | _ -> None
```

> As you can see, we identify constructors with ".ctor".

Before implementing the constructor, let's find out how we can create random
numbers in JavaScript. We'll check [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)
for that. Unlike .NET, with JS `Math.random()` we don't need to create an instance
to make random numbers and we always get floats between 0 and 1. If we want integers
in a specific range (excluding the upper limit), the same page gives us a way to do it:

```fsharp
Math.floor(Math.random() * (max - min)) + min;
```

To be compatible with .NET code, even if we don't actually need a constructor,
we have to fake one. We'll do that by just returning an empty object.

First we will create the empty JS object using the `makeJsObject` helper.
Then we will wrap the expression with `Some` to indicate we've taken care
of the call replacement.

> Though not strictly necessary in this case (we could pass `None` instead),
we add the location information (`info.range`) to improve the generation of
source maps that allow debugging the F# source in the browser.

```fsharp
| ".ctor" ->
    // makeJsObject is one of the helpers to emit Fable AST
    // in the Fable.AST.Fable.Util module
    makeJsObject info.range []
```

Now we need to deal with "Next". According to .NET documentation, `Random.Next`
has three overloads so we need to check the arguments and use default values
for the lower and upper limits of the range if they're not provided.

After that we will emit some JS code inline (using placeholders like `$0`, `$1`
for the arguments). We can call the `makeEmit` helper that also accepts the `range`
and the `returnType` as arguments.

```fsharp
| "Next" ->
    let min, max =
        match info.args with
        | [] -> makeConst 0, makeConst System.Int32.MaxValue
        | [max] -> makeConst 0, max
        | [min; max] -> min, max
        | _ -> failwith "Unexpected arg count for Random.Next"
    "Math.floor(Math.random() * ($1 - $0)) + $0"
    |> makeEmit info.range info.returnType [min; max]
    |> Some
```

To test the plugin, create a `Test.fsx` file in a `temp` folder and type the following:

```fsharp
let r = System.Random()

printfn "%i" <| r.Next()
printfn "%i" <| r.Next(10)
printfn "%i" <| r.Next(40, 50)
```

Now, from Fable's repo root folder (after building the project), compile
and run the script with:

```
node build/fable temp/Test.fsx -m commonjs --coreLib ./build/fable-core/umd --plugins src/plugins/random/Fable.Plugins.Random.fsx
node temp/Test
```

## Creating rewriter plugins

Rewriter plugins let you perform transformations on the Fable AST. This can be useful if you
want to modify how Fable handles certain constructs, or if you want to perform something along
the lines of [aspect-oriented programming](https://en.wikipedia.org/wiki/Aspect-oriented_programming)
and, for example, insert custom logging or exception handling into every function declaration
in your project.

To implement rewriter plugin, you need to implement the `IRewritePlugin` interface. For example,
let's say we want to insert a `console.log` call at the beginning of every top-level function
and use it to log the names of called functions. To do this, we can implement a rewrite plugin
that will go through all declarations and inject the call at the beginning of each function
declaration. To inject the call, we write the following helper:

```
let injectLog name expr =
  let logExpr =
    Apply
      ( Value(Emit("x=>console.log(x)")),
        [Value(StringConst name)],
        ApplyMeth, Unit, None )
  Sequential([ logExpr; expr ], None)
```

The function takes a name of function and its body and it returns a `Sequential` expression that
first calls `console.log` and then calls the original expression.  To call `console.log`, we
use Fable's `Emit` constructor, which emits inline JavaScript and we use `Apply` to call the
inline function with the function name as argument.

Next, we need to write a function to transform all declarations in a file:

```
let transformFile (file:File) =
  let newDecls =
    file.Declarations
    |> List.map (function
      | MemberDeclaration(membr, name, args, body, loc) ->
          let body = injectLog membr.Name body
          MemberDeclaration(membr, name, args, body, loc)
      | decl -> decl )

  File(file.FileName, file.Root, newDecls, file.UsedVarNames)
```

A file has a list of declarations in `file.Declarations` and so we simply iterate over all the
declarations. If the declaration is `MemberDeclaration` (meaning top-level function), we use our
`injectLog` function to add logging to its body. At the end, we create new `File` object using
the original file information and new declarations. Finally, we need to implement
`IRewritePlugin`:

```
type LoggingRewrite() =
  interface IRewritePlugin with
    member x.Rewrite(files) = files |> Seq.map transformFile
```

Here, we transform all files in the project using the `transformFile` function.
The rest is the same as in the previous example - you'll need to compile the plugin
and specify it in `fableconfig.json` and that's all you need to do!


Nice, isn't it? Now you have the capability to extend Fable to fit your own needs.
I'm looking forward to seeing the wonderful plugins you'll create!
